# 异常通知模块

## 前言

项目线上难免会遇到各种问题，一个良好的及时异常通知机制，可以让我们在异常发生时及时捕获到关键信息，以针对性的进行问题排查。

## 使用方式

### 1.引入坐标

```xml
 <dependency>
            <groupId>com.lovecyy</groupId>
            <artifactId>relaxed-common-exception</artifactId>
            <version>${version}</version>
 </dependency>
```

### 2.配置切点拦截

> 默认切点拦截配置如下，仅仅拦截带`ExceptionNotice`注解的类或方法

```java
@Override
public Pointcut build() {
   Pointcut cpc = new AnnotationMatchingPointcut(ExceptionNotice.class, true);
   Pointcut mpc = new AnnotationMethodPoint(ExceptionNotice.class);
   return new ComposablePointcut(cpc).union(mpc);
}
```

若要自定义拦截切点,需实现 PointCutRegister 重写build方法。

如下: 自定义切点 拦截`RestController`以及`ExceptionNotice`注解的

**注: 嵌套注解 以线程为维度，只会触发一次异常通知（及统一交由最外层捕获）**

```java
@Component
public class CustomPointCut implements PointCutRegister {

	@Override
	public Pointcut build() {
		Pointcut cpc = new AnnotationMatchingPointcut(ExceptionNotice.class, true);
		Pointcut mpc = new AnnotationMethodPoint(ExceptionNotice.class);
		Pointcut restMpc = new AnnotationMatchingPointcut(RestController.class);
		return new ComposablePointcut(cpc).union(mpc).union(restMpc);
	}

}
```

### 3.配置异常通知器

> 项目内置两个异常通知器1.邮件2.钉钉

#### 邮件演示

##### 1.引入邮件starter坐标

```xml
        <dependency>
            <groupId>com.lovecyy</groupId>
            <artifactId>relaxed-spring-boot-starter-mail</artifactId>
        </dependency>
```

##### 2.`ExceptionHandleProperties`异常处理属性

```java
@Data
@ConfigurationProperties(prefix = "relaxed.exception")
public class ExceptionHandleProperties {

	/**
	 * 忽略指定异常，请注意：只会忽略填写的异常类，而不会忽略该异常类的子类
	 */
	private Set<Class<? extends Throwable>> ignoreExceptions = new HashSet<>();

	/**
	 * 通知间隔时间 单位秒 默认 5分钟
	 */
	private long time = TimeUnit.MINUTES.toSeconds(5);

	/**
	 * 消息阈值 即便间隔时间没有到达设定的时间， 但是异常发生的数量达到阈值 则立即发送消息
	 */
	private int max = 5;

	/**
	 * 堆栈转string 的长度
	 */
	private int length = 3000;

	/**
	 * 接收异常通知邮件的邮箱
	 */
	private Set<String> receiveEmails = new HashSet<>();

}

```

##### 3.注册自定义`GlobalExceptionHandler`的Bean

```java
@Bean	
public GlobalExceptionHandler mailGlobalExceptionHandler(ExceptionHandleProperties exceptionHandleProperties,
			ApplicationContext context) {
		ExceptionHandleConfig exceptionHandleConfig = BeanUtil.toBean(exceptionHandleProperties,
				ExceptionHandleConfig.class);
		return new MailGlobalExceptionHandler(exceptionHandleConfig, context.getBean(MailSender.class), applicationName,
				exceptionHandleProperties.getReceiveEmails());
	}

```

##### 4.配置`application-web.yml`

```yml
spring:
  application:
    name: test-web
  mail:
    host: smtp.163.com
    port: 25
    username: username@163.com
    password: password
    default-encoding: UTF-8
    properties:
      from: username@163.com
      mail.smtp.auth: true
      mail.smtp.starttls.enable: true
      mail.smtp.starttls.required: true
      mail.smtp.socketFactory.port: 465
      mail.smtp.socketFactory.class: javax.net.ssl.SSLSocketFactory
      mail.smtp.socketFactory.fallback: false
relaxed:
  exception:
    receiveEmails: receivename@vipsave.cn
    max: 1

```

### 4.开始测试

#### 1.创建`AsyncService` 

```java
@Component
public class  AsyncService {

	@ExceptionNotice
	public void asyncError() {
		if (true) {
			throw new RuntimeException("异步任务处理出现异常");
		}
	}

}
```

#### 2.创建`TestService`

```java
@ExceptionNotice
@Component
public class TestService {

	@Autowired
	private TestAsyncService testAsyncService;

	public String helloNoAnnotationReturn() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				testAsyncService.asyncError();
			}
		}).start();
		if (true) {
			throw new RuntimeException("接口调用出现异常");
		}
		return "hello";
	}

}
```

#### 3.创建`TestController`

```java
@RestController
@RequestMapping("/test")
public class TestController {

	@Autowired
	private TestService testService;

	@GetMapping("/hello")
	public R test() {
		testService.helloNoAnnotationReturn();
		return R.ok();
	}

}

```

4.测试方法

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("web")
@AutoConfigureMockMvc
public class WebRequestTest {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void testWeb() throws Exception {
		MvcResult mvcResult = null;
		try {
			mvcResult = mockMvc.perform(get("/test/hello")).andReturn();
		}
		catch (Exception e) {
         //ignore
		}
		Thread.sleep(50000);
		System.out.println(mvcResult);

	}

}
```

